---
layout: posts
title:  "What' Been Happening: Week 44"
date:   2020-10-29 00:05:00 +0100
categories: update dev-diary
---


Here’s the rundown of what I’ve done week 44.

I started the week getting the hang of two different APIs that I will use for my coursework that is about learning (surprise surprise!) how to read documentation and implement application interfaces that one might not be masterful in. The two APIs I’ve decided on using are WPF and ASP.NET. I decided on these two APIs as they are both Microsoft-made interfaces that have years of usage online if I ever were to get stuck, as well as both having quite detailed documentation. Now, you might wonder, what is WPF and ASP.NET? Well, WPF stands for Windows Presentation Foundation and is a graphical user interface library used for many Windows based applications. It’s designer functionality builds off of XAML-files which is a markup language for visualizing every part of the UX of the application. ASP.NET is a server-side web framework mostly used for web applications, but the framework itself can be used to create Peer-to-Peer applications, a method of networking where the client works as a server for the user’s peer to connect to. This is used to circumvent the usage of servers on the developer’s side, meaning the application will not be made redundant because the developer decided to turn off the server.

Hoo boy, that was a lot of mumbo jumbo, so let’s make it simple. WPF is all of the stuff you see (aka *the front end*). ASP.NET is the network stuff that lets you, the user, connect to another user in another place (aka *the back end*). Now, here’s the kicker. For the coursework in question, we have to create some piece of software, tool, or gameplay addition that utilizes at least ***one*** external API. That’s right, ***one***. So why am I using ***two*** APIs? Well, WPF has a simpler brother called Windows Forms. Windows Forms is another great graphical user interface library that is also commonly used for a lot of Windows applications. It is an API that I first used back in 2016, and have made a lot of applications that have never seen the light of day. These tools were mostly internal apps that helped me personally and were made with my machine in mind alone. However, as good as Windows Forms is, I find it personally quite clunky as it is more about the designer experience alone and then the programming experience alone. With WPF, these two experiences are more intertwined and would allow me to switch between programming the backend and frontend at a second’s notice. Additionally, WPF is still similar to Windows Forms in a lot of ways, and thereby this minor transition would be nothing but a miniscule hitch in my development. So, yes, the project in question is utilizing two different APIs, but the focus lies with ASP.NET, an API that I have never worked with prior to this week.

With that out of the way, let me introduce you to my software!

![chat-function](/Assets/posts/chat_function.gif)

Wow, so cool! This is revolutionary, industry-changing, will change the virtual landscape forever, I hear you say through the monitor. Please, you humble me. But in all honesty, yes. This isn’t very impressive on the surface level. It’s two windows talking to each other, big deal. But that’s where the untrained eye is wrong! What is actually happening here is that I am using my local IP to connect two instances of the same software to each other. They don’t speak on a client level at all, they’re not “actually the same instance but two different windows so they share variables.” No, these are different clients communicating. Now, in theory, this should work cross machine, but I have yet to get that to work and that is what I will spend next week trying to solve. But let me try to explain what is happening here then, and fair warning! There will be some tech nonsense coming up so don’t be scared of that!

So what is happening here? First off, we have each user filling out their username. That part is simple, and the username is simply to let the users know who wrote what. What’s next then? Well, the users both enter a port that the other user will use to connect to their IP with. See the port as an identifier for the connecting user to know where you will be communicating. If the IP is their phone number, the port is the channel you will call them through. Then there’s the IP, or partner address. This is where the user enters the IP of the user they will connect with, as well as the port that that user entered to properly connect to each channel. With those parameters down, the users can both press the “Start Chat!” button and start chatting! With the chat active, both users have the software running a local server on their machine and on their IP address. By having the users connect to that server and then route through the software according to a route template set in code, certain methods can be called when an event happens, such as a message being sent. In this case, when a message is being sent, that message is passed through the server and sends it to the connected client. Once it reaches the client, the method will be invoked and will show up in the client’s window. Pretty simple, right?

But all of this code, these clients and these self-hosted servers, they’re not my coursework. All of this code was simply for me to get to grips with how ASP.NET works. The project I’m making here isn’t just a chatting application, but rather a simplistic turn-based game, such as Tic Tac Toe with an added chat functionality that doesn’t rely on a server. So whilst this has been informative, and I am more confident in my abilities now than I was a week ago, as soon as I figure out how to solve the cross machine problem I’m currently facing, this particular instance of the project will be used for reference as I’ll start tackling the actual assessment.
